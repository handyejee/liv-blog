---
title: 명령어와 CPU의 작동원리
date: '2025-02-12'
tags: ['TIL', '컴퓨터구조']
draft: false
summary: 혼자 공부하는 컴퓨터구조 운영체제(4-5장)
---
본 시리즈는 혼자 공부하는 컴퓨터 구조 책을 스터디 하며 남기는 기록 중 두번째 시리즈 입니다.

## 명령어
### 03-1 소스코드와 명령어
- 컴퓨터가 이해할 수 있는 언어는 저급언어
	- 고급언어는 저급언어로의 변환 필요
- 저급 언어의 종류는 기계어와 어셈블리어
	- 기계어는 0, 1로만 이루어진 언어, 혹은 16진수로 표현된 언어
	- 어셈블리어는 기계어를 읽기 쉽게 번역한 언어
	- 어셈블리어로만 복잡한 프로그램을 만들기 어려움 -> 고급언어의 필요성
- 고급언어를 변환하는 방식 : 컴파일 언어, 인터프리터 언어
	- 컴파일 언어
		- 컴파일러 통해 소스코드 전체 변환 -> 변환된 코드는 목적코드(object code)
		- 오류가 있으면 전체 소스코드 컴파일 실패해 실행되지 않음
	- 인터프리터 언어
		- 인터프리터 통해 한 줄씩 변환
		-  한 줄씩 해석하고 실행해 컴파일 언어보다 느림
- 목적 파일 -> 실행 파일 되기 위해서 linking(링킹) 작업 필요

### 03-2 명령어의 구조
- 명령어 구성
	- 연산코드(= 연산자) : 명령어가 수행 할 연산
	- 오퍼랜드(= 피연산자) : 연산에 사용할 데이터 혹은 연산에 사용할 데이터가 저장된 위치
- 연산코드 종류
	- 데이터 전송
	- 산술/논리 연산
	- 제어흐름변경
		- 특정 메모리 주소로 옮기는 것
	- 입출력 제어
- 오퍼랜드 필드에 주소를 저장하는 이유 ? -> 명령어에 저장하는 데이터의 크기가 정해져 있기 때문
- 명령어 주소 지정 방식
	- 유효 주소 : 연산에 사용할 데이터가 저장된 위치
	- 명령어 주소 지정 방식
		- 즉시 주소 지정 방식(Immediate addressing mode)
			- **연산에 사용할 데이터**를 오퍼랜드 필드에 직접 명시
		- 직접 주소 지정 방식(Direct addressing mode)
			- 오퍼랜드 필드에 **유효주소**를 직접 명시
		- 간접 주소 지정 방식(Indirect addressing mode)
			- **유효 주소의 주소**를 오퍼랜드 필드에 명시(속도 느림)
		- 레지스터 주소 지정 방식
			- **유효 주소**를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
		- 레지스터 간접 주소 지정 방식
			- 유효 주소를 저장한 레지스터

## CPU의 작동원리
### 04-1 ALU와 제어장치
- ALU : 계산하는 장치
	- 계산하기 위해 필요한 정보를 받아들인다
	- 내보내는 정보: 계산한 값, 플래그
		- 메모리가 아닌 ALU에 저장하는 이유 ? 
			- CPU가 레지스터에 접근하는 속도가 메모리에 접근하는 속도보다 빠르기 때문
	- 플래그 : 연산 결과에 대한 부가정보
		- 연산 결과가 레지스터 보다 크면 ALU가 결과값이 크다는 정보 -> overflow
- 제어장치
	- 제어신호 받아들이기
		- clock 신호를 받아들임
		- 해석해야 할 명령어를 받아들임
		- 플래그 레지스터 속 플래그 값 받아들임
		- 제어버스로 전달된 제어신호 받아들이기
	- 제어신호 내보내기
		- CPU 내부, 외부로 제어신호를 보낸다
### 04-2 레지스터
	
### 04-3 명령어 사이클과 인터럽트
### 알게된점			

### 참고자료

[혼자 공부하는 컴퓨터 구조 + 운영체제](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=299014282)<br></br>