---
title: 명령어와 CPU의 작동원리
date: '2025-02-12'
tags: ['TIL', '컴퓨터구조']
draft: false
summary: 혼자 공부하는 컴퓨터구조 운영체제(4-5장)
---
본 시리즈는 혼자 공부하는 컴퓨터 구조 책을 스터디 하며 남기는 기록 중 두번째 시리즈 입니다.
[이전 시리즈 보러가기](https://liv-blog.vercel.app/blog/TIL_20250205)

## 명령어

### 03-1 소스코드와 명령어

- 컴퓨터가 이해할 수 있는 언어는 저급언어
	- 고급언어는 저급언어로의 변환 필요
- 저급 언어의 종류는 기계어와 어셈블리어
	- 기계어는 0, 1로만 이루어진 언어, 혹은 16진수로 표현된 언어
	- 어셈블리어는 기계어를 읽기 쉽게 번역한 언어
	- 어셈블리어로만 복잡한 프로그램을 만들기 어려움 -> 고급언어의 필요성
- 고급언어를 변환하는 방식 : 컴파일 언어, 인터프리터 언어
	- 컴파일 언어
		- 컴파일러 통해 소스코드 전체 변환 -> 변환된 코드는 목적코드(object code)
		- 오류가 있으면 전체 소스코드 컴파일 실패해 실행되지 않음
	- 인터프리터 언어
		- 인터프리터 통해 한 줄씩 변환
		-  한 줄씩 해석하고 실행해 컴파일 언어보다 느림
- 목적 파일 -> 실행 파일 되기 위해서 linking(링킹) 작업 필요

### 03-2 명령어의 구조

- 명령어 구성
	- 연산코드(= 연산자) : 명령어가 수행 할 연산
	- 오퍼랜드(= 피연산자) : 연산에 사용할 데이터 혹은 연산에 사용할 데이터가 저장된 위치
- 연산코드 종류
	- 데이터 전송
	- 산술/논리 연산
	- 제어흐름변경
		- 특정 메모리 주소로 옮기는 것
	- 입출력 제어
- 오퍼랜드 필드에 주소를 저장하는 이유 ? -> 명령어에 저장하는 데이터의 크기가 정해져 있기 때문
- 명령어 주소 지정 방식
	- 유효 주소 : 연산에 사용할 데이터가 저장된 위치
	- 명령어 주소 지정 방식
		- 즉시 주소 지정 방식(Immediate addressing mode)
			- **연산에 사용할 데이터**를 오퍼랜드 필드에 직접 명시
		- 직접 주소 지정 방식(Direct addressing mode)
			- 오퍼랜드 필드에 **유효주소**를 직접 명시
		- 간접 주소 지정 방식(Indirect addressing mode)
			- **유효 주소의 주소**를 오퍼랜드 필드에 명시(속도 느림)
		- 레지스터 주소 지정 방식
			- **유효 주소**를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
		- 레지스터 간접 주소 지정 방식
			- 유효 주소를 저장한 레지스터

## CPU의 작동원리

### 04-1 ALU와 제어장치

- CPU는 ALU, 제어장치, 레지스터로 구성
- ALU : 계산하는 장치
	- 계산하기 위해 필요한 정보를 받아들인다
	- 내보내는 정보: 계산한 값, 플래그
		- 메모리가 아닌 ALU에 저장하는 이유 ?
			- CPU가 레지스터에 접근하는 속도가 메모리에 접근하는 속도보다 빠르기 때문
	- 플래그 : 연산 결과에 대한 부가정보
		- 연산 결과가 레지스터 보다 크면 ALU가 결과값이 크다는 정보 -> overflow
- 제어장치
	- 제어신호 받아들이기
		- clock 신호를 받아들임
		- 해석해야 할 명령어를 받아들임
		- 플래그 레지스터 속 플래그 값 받아들임
		- 제어버스로 전달된 제어신호 받아들이기
	- 제어신호 내보내기
		- CPU 내부, 외부로 제어신호를 보낸다

### 04-2 레지스터

- 상용화된 CPU 내 레지스터 중 가장 많은 CPU가 포함하고 있는 레지스터
- 프로그램 카운터(Program Counter) = 명령어 포인터
	- 메모리에서 읽어 들일 **명령어의 주소** 저장
- 명령어 레지스터(Instruction Register)
	- 해석할 **명령어**를 저장하는 레지스터
- 메모리 주소 레지스터(Memory Address Register)
	- 메모리의 주소를 저장하는 레지스터
- 메모리 버퍼 레지스터
	- 메모리와 주고받을 값을 저장하는 레지스터
- 범용 레지스터
	- 다양한 상황에서 사용할 수 있는 레지스터

### 04-3 명령어 사이클과 인터럽트

- 명령어 사이클 
	- 프로그램 명령어가 일정한 사이클로 반복
- 인터럽트
	- CPU가 처리해야 할 다른 작업이 생겼을때 발생
	- 동기 인터럽트(예외)
		- CPU가 예상하지 못한 상황 접했을 때 발생
	- 하드웨어 인터럽트
		- 사용이유?
			- 입출력 작업 도중에도 명령어 처리 가능
				-> 인터럽트 있으면 입출력 작업 하는 동안 CPU 다른 일 할 수 있다
		- 처리 순서
			- 인터럽트 요청 신호(처리 전)
				- 입출력장치 -> CPU 에게 인터럽트 실행 가능여부 확인
		- CPU가 인터럽트를 처리한다 == 인터럽트 서비스 루틴을 실행하고 수행하던 작업으로 다시 되돌아온다
			- 인터럽트 시작 주소는 인터럽트 백터를 통해 알 수 있다
		- 실행했을때 현재 CPU, 레지스터에 수행중인 작업을 유지해야함(백업)

### 알게된점

하드웨어 레벨에서 명령어가 어떻게 동작하고 입출력 장치와 어떻게 소통하는지에 대해서 알 수 있었습니다. 오버플로우의 경우 JVM에서 주는것만 알았는데 CPU단에서 ALU가 계산하면서 발생하는 부분도 있다는 것을 알게되었습니다.ㄴ

### 참고자료

[혼자 공부하는 컴퓨터 구조 + 운영체제](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=299014282)<br></br>